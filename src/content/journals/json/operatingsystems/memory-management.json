[{"type":"paragraph","data":[{"style":"text","value":"RAM: Random access memory is a fast storage space where running programs exists. The OS needs a mechanism to track free and allocated memory."}]},{"type":"paragraph","data":[{"style":"strong","value":"Track Free List"},{"style":"text","value":": maintan a list of memory chuncks by storing a starting location and size of avaible bytes from that location."}]},{"type":"list","data":{"style":"ul","data":[[{"style":"strong","value":"Allocation Policies"},{"style":"text","value":":"}],[[{"style":"strong","value":"First Fit"},{"style":"text","value":": use the first item which is large enough"}],[[{"style":"text","value":"fast"}]],[{"style":"strong","value":"Best Fit"},{"style":"text","value":": use the smallest item that is large enough"}],[[{"style":"text","value":"save large chunks"}]],[{"style":"strong","value":"Worst Fit"},{"style":"text","value":": use the largest item thats large enough"}],[[{"style":"text","value":"avoids fragmentation"}]]],[{"style":"strong","value":"Freed Policies"},{"style":"text","value":":"}],[[{"style":"strong","value":"Front"},{"style":"text","value":": place free memory at the front of the list"}],[[{"style":"text","value":"fast"}]],[{"style":"strong","value":"Order by address"},{"style":"text","value":": good for coalescing chunks"}],[{"style":"strong","value":"Order by length"},{"style":"text","value":": good for when allocating"}]]]}},{"type":"paragraph","data":[{"style":"strong","value":"Segmentation"},{"style":"text","value":":"}]},{"type":"list","data":{"style":"ul","data":[[{"style":"strong","value":"Base and Bounds"},{"style":"text","value":": Each and every process has a contigous piece of the phyical memory (virtaual memory), marked with a base and bounds"}],[[{"style":"strong","value":"pitfall"},{"style":"text","value":": since most processes wont use the entire congigous space, the system would be wasting valuable memory"}]],[{"style":"strong","value":"Segment virtual memory"},{"style":"text","value":": rather than each process having a contuguos piece,give each process receives 3 smaller segmented chuncks allocated from 3 different locations in the physical memory"}],[[{"style":"strong","value":"Address Translation"},{"style":"text","value":": 2^14 address space (16 KB), 2 bits give the segement, 12 bits give the offset"}],[[{"style":"text","value":"top tow bis:"}],[[{"style":"text","value":"00: code"}],[{"style":"text","value":"01: heap"}],[{"style":"text","value":"10: unused"}],[{"style":"text","value":"11:stack"}]],[{"style":"strong","value":"Protection"},{"style":"text","value":": we can assign permsission to each segment"}],[[{"style":"text","value":"e.g heap,stack: read-write"}],[{"style":"text","value":"code: read-execute"}]],[{"style":"strong","value":"Sharing Code"},{"style":"text","value":": w/read only persmision, two processes running the same app, can map to the same code segment"}],[{"style":"strong","value":"Pitfall"},{"style":"text","value":": variable sized seqments lead to fragmentation aka wasted memory"}]]],[{"style":"strong","value":"Paging"},{"style":"text","value":": rather than allocating vairbale segments,divide the physicall address space into equal size segments (pages)."}],[[{"style":"text","value":"rather than allocating memory, OS hands processes pages"}],[{"style":"strong","value":"Address Translation"},{"style":"text","value":":"}],[[{"style":"text","value":"In order to map virtual address space to phycial address space we need a translation table."}],[[{"style":"text","value":"e.g virtual space of 64 Bytes made from 4 pages of 16 byte size, the virtaul address would be 6 bits long, use 2 bits to locate page remaining  4 bits to locate offset"}],[{"style":"text","value":"e.g physical space of 128 Bytes / 16 byte frames would = 8 page. the physcal address would be 7 bits long. 3 bits locate the page, remaning 4 locate offset"}],[{"style":"text","value":"2 bits from virtual page number (vpn) need to be mapped into a the 3 bit from the physical page number (PFN)"}]]],[[{"style":"text","value":"valid: is the translation valid"}],[{"style":"text","value":"protection: read/write/execture protection"}],[{"style":"text","value":"dirty: has a page been modified since beign brought into memory"}],[{"style":"text","value":"reference:has a page been accessed"}]]],[{"style":"strong","value":"Pitfalls"},{"style":"text","value":":"}],[[{"style":"text","value":"page table size: with larger virtual address spaces we need to allocate more memory for the page table"}],[[{"style":"text","value":"2^32 bit virtual address w/ 4 KB sized pages, would require a 2^20 bit row table ~ 1 M rows"}]],[{"style":"text","value":"Speed: since we cant fit table into MMU registers, then we now have a process that each translation musc go through, to store the MMU pointers"}]]]}},{"type":"heading","data":{"depth":2,"text":[{"style":"text","value":"Concurrency"}],"id":"concurrency"}}]