[{"type":"paragraph","data":[{"style":"strong","value":"Program vs Process"},{"style":"text","value":":"}]},{"type":"list","data":{"style":"ul","data":[[{"style":"text","value":"Program: is file which contains a set of instuctions"}],[{"style":"text","value":"Process: is what the program launches, process need to maintain a state and require computer resouces"}]]}},{"type":"paragraph","data":[{"style":"text","value":"The operating sytem is in charge of manageing processes, and ensuring that each program gets a fair chance to run."}]},{"type":"paragraph","data":[{"style":"strong","value":"Multi-Programming"},{"style":"text","value":":gives the illusion that there are multiple process running simultaneousely, the is done by time division multiplexing;aka allocating a very short time slot to each program to be able to run."}]},{"type":"paragraph","data":[{"style":"text","value":"To accomplish this the OS must maintain the execution state of each process, running or ready to run."}]},{"type":"paragraph","data":[{"style":"text","value":"How a process is created:"}]},{"type":"list","data":{"style":"ul","data":[[{"style":"text","value":"OS retrieves program and loads it into memory"}],[{"style":"text","value":"allocates memory for static data, call stack and memeory heap"}],[{"style":"text","value":"initialize file descriptors"}],[{"style":"text","value":"allow the program time to use its required resources such as controll over the CPU"}]]}},{"type":"paragraph","data":[{"style":"strong","value":"Potential Pitfall"},{"style":"text","value":": Since the OS hands over control to the program, how can the OS then ensure that the program doesnt \"take over\" as in not hog the resources ?"}]},{"type":"paragraph","data":[{"style":"strong","value":"Context Switching with Timer Interrupts"},{"style":"text","value":": in order to prevent a program from taking over, make se a hardware interrupts in order to stop the current process."}]},{"type":"list","data":{"style":"ul","data":[[{"style":"strong","value":"Hardware interrupts"},{"style":"text","value":": some hardware components have the ability to interrupt the CPU by sending it a signal, when the CPU hears the signal, it stops the current process, saves its registers and calls on the OS to deal with it"}],[[{"style":"text","value":"The signal gets logged into a trap table, where then the OS will read and handle the interrupt signal"}]],[{"style":"strong","value":"OS are event driven"},{"style":"text","value":":"}],[[{"style":"text","value":"Interrups: e.g  mouse click, timer or harddrive"}],[{"style":"text","value":"Process Exception: e.g  floating point error, invalid memory access"}],[{"style":"text","value":"Systeam Call: e.g read file"}]]]}},{"type":"paragraph","data":[{"style":"strong","value":"Process Scheduling"},{"style":"text","value":":"}]},{"type":"list","data":{"style":"ul","data":[[{"style":"strong","value":"First-come,First Serve (FCFS)"},{"style":"text","value":": queue up jobs in the order in which they arrive"}],[[{"style":"strong","value":"Pitfall"},{"style":"text","value":": could lead to long turn around times if a shorter job arrives after two longer jobs"}]],[{"style":"strong","value":"Shortest Job First (SJF)"},{"style":"text","value":": when jobs arrive at the same time, execute the one which would take the shortest to complete"}],[[{"style":"strong","value":"pitfall"},{"style":"text","value":": a shorter job may arrive a short time after longer jobs have been queued, in other words it still acts as FCFS"}]],[{"style":"strong","value":"Shortest Time-to-Completion First (STCF)"},{"style":"text","value":": if a shorter job arrives, interrup the current job an run the next shortest"}]]}},{"type":"list","data":{"style":"ul","data":[[{"style":"strong","value":"Round Robin"},{"style":"text","value":": rather than running current job to completion, allocate each job a time slice and alternate between each job."}],[[{"style":"text","value":"Impoves response time, but its bad for turn around time"}]]]}},{"type":"paragraph","data":[{"style":"strong","value":"Multi-Level Feedback queue"},{"style":"text","value":": as new jobs come in assign them the hig level of priority. Allow them to run for a short amount of time, if it finishes during this period, you acheive fast turnaround times. If it doesnt finish within this period, it will go down in priority."}]},{"type":"list","data":{"style":"ul","data":[[{"style":"strong","value":"Pitfall"},{"style":"text","value":":"}],[[{"style":"text","value":"Starvation, if there are constatnly always higher priority jobs, there can exists a job in a very low priority that will never run."}],[{"style":"text","value":"Gamming the System: since every I/O job is a new job, a process can game the system by running I/O jobs before its time slice ends thus remains high priority"}]],[{"style":"strong","value":"Bootsing"},{"style":"text","value":": boost every job up to the highest priority every nowand again"}]]}},{"type":"paragraph","data":[{"style":"text","value":"A process typically needs to use both the CPU and I/O devices."}]},{"type":"code","data":{"lang":"c","meta":"';","value":"x = x * 5;                                  //cpu \nchar *status = fgets(s,MAX_BUF-1,infile);   //I/O"}},{"type":"paragraph","data":[{"style":"text","value":"When a the process interacts with I/O it does nothing with its allocated time with the CPU, in other words its wasting time that another process could be using."}]},{"type":"heading","data":{"depth":2,"text":[{"style":"text","value":"Memory Management"}],"id":"memory-management"}}]